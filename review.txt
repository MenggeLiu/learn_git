=====本地git操作，可方便管理本地一个分支的代码文件=====

git init # 初始化一个git仓库

git add "filename" # 添加新文件到git仓库

git commit -m “massage” # 将文件提交到代码仓库，并添加说明

git status # 查看当前工作树状态

git diff "filename" # 查看修改的文件的具体修改内容

git log --pretty=oneline # 查看修改日志，每次修改一行

git reset --hard HEAD^ # 退回到上一步

git reset --hard "版本号" # 退回到指定版本，可用git log 查询，只要能找到版本号就可以自由切换

git reflog # 如果退回到之前版本，又想恢复新版本，而之前的窗口已经关闭无法查看之前的残留信息，可用该命令来查看所有的历史命令

git 跟踪的是修改而不是文件，比如在第一次修改并add后第二次修改了文件，commit并不会提交第二次修改的内容，
	因为第二次的修改并没有存入暂存区，而commit只是将暂存区的内容提交

git checkout -- 'filename' # 丢弃工作区的修改内容，根据文件是否被add，如果未被add就退回到版本库，如果被add就退回到暂存区
	# 本质上是用版本库的文件来替换工作区的文件，可用于误删文件找回

git reset HEAD 'filename' # 如果工作已经提交到暂存区，可使用reset来将暂存区退回到工作区

git rm 'filename'  # 从版本库中删除文件

=====

=====远程仓库=====

利用GitHub作为远程仓库，来同步保存本地工作

首先需要注册github，创建公私钥来实现本地和远程的配对匹配

登录后创建新的代码仓，根据页面提醒，可同步本地代码仓，默认为origin分支

git push -u origin master # 把本地的所有内容推送到远程仓库（首次使用需要-u）

从远程仓库克隆时，先在GitHub创建一个仓库，然后使用git clone命令即可

git clone 'git-url' # 把代码仓克隆到本地

=====

=====分支管理=====

把每次的提交看作一条时间线，严格来讲HEAD并不指向某一次的提交，而是指向master分支（即主分支）
每次提交，master分支向前移动一步，HEAD也随着master而移动，创建新的dev分支时，本质上只是创建了一个新的指针

git checkout -b dev # 创建并切换到dev分支

git branch dev
git checkout dev # 创建并切换到dev分支（分两步）
# 感觉每次先确认工作区状态再进行切换分子较为合适，防止出现一些奇怪的事情

git merge dev # dev有了新的提交后，在master下可以合并dev的修改，相当于把master同步到dev的提交记录点

git switch -c dev # 创建并切换到dev分支，采用switch方法看起来更为科学

git switch master # 切换到已有的分支

#this is in dev



